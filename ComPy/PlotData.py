from glob import glob
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
from matplotlib.backends.backend_pdf import PdfPages
#from matplotlib_venn import venn3_unweighted, venn3_circles, venn2_unweighted
import pandas as pd
from matplotlib.gridspec import GridSpec
from PyPDF2 import PdfFileMerger
from .DbManager import DBManager
import shutil
import logging
import multiprocessing
from tqdm import tqdm

from .Additional_Software.pyvenn.venn import get_labels, venn2, venn3, venn4, venn5



        
        
        
###Class for plotting the data previously saved in the database
class PlotTheData():
    def __init__(self, tool, outputpathtmp, outputpath, pathDB, 
                 reduceBed = False, bamnames = False, subsamples = False, 
                 threads = False, small = 12, medium = 17, large = 27, 
                 samplenumber = 8, variants = False, bedid = False, 
                 dicIDs = False, vcfdata = False, VcfPlotTable = False, 
                 FileClass = False):
                
        self.headersize = 16
        plt.rcParams["ytick.labelsize"] = 10
        plt.rcParams["xtick.labelsize"] = 10
        plt.rcParams["axes.labelsize"] = 10
        plt.rcParams["axes.titlesize"] = 16
        plt.rcParams["legend.fontsize"] = 10
        plt.rcParams["legend.title_fontsize"] = 10

        self.out = outputpath                               #Path where the results should be saved at
        self.outtmp = outputpathtmp                         #Path where the tmp pdf should be saved at
        self.pathDB = pathDB                                #Path to previously generated database
        self.bedid = bedid                                  #.bed ID generated by Preparation.py
        self.bamnames = bamnames                            #List of all .bam names
        self.subsamples = subsamples                        #Number of subsamples takes for QC
        self.variants = variants
        self.dicIDs = dicIDs
        self.dicIDsBam = {}
        self.dicIDsVCF = {}
        print(self.dicIDs)
        for intID in self.dicIDs.keys():
            if self.dicIDs[intID][2] == "bam":
                self.dicIDsBam[intID] = self.dicIDs[intID]
            elif self.dicIDs[intID][2] == "vcf":
                self.dicIDsVCF[intID] = self.dicIDs[intID]
                
        self.samplenumber = samplenumber                    #To determine number of rows and figure size (is defined for each plot separately) 
        
        if reduceBed:
            self.strReduce = "Yes"
            self.reducedDB = 1
        else:
            self.strReduce = "No"
            self.reducedDB = 0
            
        if FileClass:
            self.FileClass = FileClass
        else:
            self.FileClass = "Default"
            
        #Initiale logging tool
        self.comptoollog = logging.getLogger("ComparisonTool")
        
        #Initiate the data
        self.GetTheData(VcfPlotTable)
        
        #Start plotting
        pool = multiprocessing.Pool(processes=threads)
        lsJobs = []
        if tool in ["all", "bam"]:
            lsJobs.append(pool.apply_async(self.PlotOnTarget))
            lsJobs.append(pool.apply_async(self.PlotGCvsCov))
            lsJobs.append(pool.apply_async(self.PlotCoverage))
            lsJobs.append(pool.apply_async(self.PlotQCmetrics, args=("1",)))
            lsJobs.append(pool.apply_async(self.PlotQCmetrics, args=("2",)))
        elif tool in ["all", "vcf"] and self.variants:
            #Plot of number of variants, allelefrequency distribution and shared variants between the .vcf data
            lsJobs.append(
                pool.apply_async(self.PlotVariantData, args=(vcfdata,))
            ) 
        for job in tqdm(lsJobs):
            job.get()
        pool.close()
        
        
        
        
        
        
        
        
        
        
        
    def GetTheData(self, VcfPlotTable):
        ##Start extracting data from database
        bamcheck = [x for x in self.dicIDsBam.keys()]
        print(bamcheck)
        self.detaildata = DBManager.ExtractData(
            "ReadStatistiks", self.pathDB, ID= bamcheck
        )
        self.detaildata["MeanC"] = pd.to_numeric(self.detaildata["MeanC"])
        self.detaildata["Total"] = pd.to_numeric(self.detaildata["Total"])
        self.detaildata["Mapped"] = pd.to_numeric(self.detaildata["Mapped"])
        self.detaildata["GC"] = pd.to_numeric(self.detaildata["GC"])
        
        self.phreddata = DBManager.ExtractData(
            "QCmetrics", self.pathDB, ID= bamcheck
        )
        self.phreddata["PHREDmean"] = pd.to_numeric(
            self.phreddata["PHREDmean"]
        )
        self.phreddata["PHREDsd"] = pd.to_numeric(
            self.phreddata["PHREDsd"]
        )
        self.phreddata["ReadCount"] = pd.to_numeric(
            self.phreddata["ReadCount"]
        )
        
        if self.variants:
            vcfcheck = [x for x in self.dicIDsVCF.keys()]
            self.dfvariants = DBManager.ExtractData(
                "Extracted_Variants", self.pathDB, ID= vcfcheck
            )
            self.dfvariants["Allelefrequency"] = pd.to_numeric(
                self.dfvariants["Allelefrequency"]
            )
        
        self.mappdata = DBManager.ExtractData(
            "ReadMapping", self.pathDB, ID= bamcheck
        )
        self.mappdata["Total"] = pd.to_numeric(self.mappdata["Total"])
        
        
        ##Define Chromosomes and order them to use it in every plotting
        lsChrom = list(set(self.detaildata["Chrom"].values))
        lsGender = []
        if "X" in lsChrom: 
            intIndex = lsChrom.index("X")
            lsGender.append("X")
            lsChrom.pop(intIndex)
        if "Y" in lsChrom:
            intIndex = lsChrom.index("Y")
            lsGender.append("Y")
            lsChrom.pop(intIndex)
        lsChrom = [int(x) for x in lsChrom]
        lsChrom.sort()
        lsChrom += lsGender
        self.lsChrom = [str(x) for x in lsChrom]
        
        self.vennplots = False
        if VcfPlotTable:
            self.vennplots = pd.read_csv(VcfPlotTable)
            #print(self.vennplots)


    
    ###Create raw plot grid
    def GetPlotGrid(self, numcols, samples):
        ##Create main figure
        
        
        
        if len(samples) == 1:
            numrows = 1
            numcols = 1
            intSize = 12
        else:
            numSample = len(samples)
            numrows = numSample//numcols
            if numrows * numcols < numSample:
                numrows += 1
            intSize = 12 * numcols
        imgFigu = plt.figure(figsize=(intSize, 6*numrows))
        ##Create outer gridspec
        gridout = GridSpec(
            nrows=numrows, ncols = numcols, wspace = 0.5, hspace = 0.5
        )

        return imgFigu, gridout
    
    
    
    
    
    ###Plot percentage of reads which are not mapped (per chromosome)
    def PlotOnTarget(self):
        with PdfPages(self.outtmp+"OnTarget.pdf") as pdfFile:
            
            ##Create main figure
            imgFigu, gridout = self.GetPlotGrid(4, self.bamnames)

            
            #plt.suptitle("Percentage of reads not on target \n Subsamples: {}, Reduced: {} \n".format(self.subsamples,self.strReduce), fontsize = self.headersize)
            
            #Start plotting
            cPlt = 0
            for intID in self.dicIDsBam.keys():   #Plot each .bam file separately
                
                #Get the data
                data = self.detaildata.loc[(self.detaildata["ID"]==intID)]
                datamap = self.mappdata.loc[(self.mappdata["ID"]==intID)]
                lsOnTrg = []
                for chromosome in self.lsChrom:
                    try:
                        lsOnTrg.append(
                            (
                                sum(
                                    data.loc[
                                        data[
                                            "Chrom"
                                            ]==chromosome
                                        ]["Mapped"].to_list()
                            )\
                            /sum(
                                datamap.loc[
                                    datamap[
                                        "Chrom"
                                            ]==chromosome
                                    ]["Total"].to_list()
                                ))\
                            *100
                        )
                    except Exception as e:
                        lsOnTrg.append(0)
                        self.comptoollog.info(
                            f"No mapped reads found: {chromosome}"
                        )
                #Plot the prepared data
                subplt = plt.Subplot(imgFigu, gridout[cPlt])
                subplt.bar(x=self.lsChrom, height=lsOnTrg)
                subplt.set_ylim(80,100)
                subplt.set_title(
                    str(
                        "% of reads on target \n "
                        +f"{self.dicIDsBam[intID][0]}, "
                        +f"Reduced:{self.strReduce}, "
                        +f"Subsamples: {self.subsamples}, "
                        +f"Filtered:{self.FileClass}, "
                        +f"BED-ID:{self.bedid}"
                    )
                )
                subplt.set_xlabel("Chromosome")
                subplt.set_ylabel("% reads on target per chromosome")
                imgFigu.add_subplot(subplt)
                cPlt += 1
            
            ##Save figure
            #imgFigu.tight_layout()
            pdfFile.savefig(imgFigu)
        
        
        
        
    ###Plot context of GC content and coverage per chromosome
    def PlotGCvsCov(self):
        with PdfPages(self.outtmp+"LowCov.pdf") as pdfFile:
            
            ##Create main figure
            imgFigu, gridout = self.GetPlotGrid(4, self.bamnames)
            #plt.suptitle("Coverage depending on GC content (per chromosome) \n Subsamples: {}, Reduced: {} \n".format(self.subsamples,self.strReduce), fontsize = self.headersize)
            
            ##Start plotting
            cPlt = 0
            for intID in self.dicIDsBam.keys():   #Each .bam file will be plotted separately
                #Get the data
                
                
                data = self.detaildata.loc[
                    (self.detaildata["ID"] == intID) \
                    & (self.detaildata["MeanC"] < 50)
                ]
                usedData = pd.DataFrame(
                    columns = (["Chrom", "Thresh", "Number"])
                )
                lsAdd = []
                for chrom in self.lsChrom:
                    lsAdd.append(
                        [
                            chrom, "50", 
                            len(data.loc[(data["Chrom"] == chrom) \
                                         & (data["MeanC"]< 50)].values)
                        ]
                    )
                    lsAdd.append(
                        [
                            chrom, "30", 
                            len(data.loc[(data["Chrom"] == chrom) \
                                         & (data["MeanC"]< 30)].values)
                        ]
                    )
                    lsAdd.append(
                        [
                            chrom, "10", 
                            len(data.loc[(data["Chrom"] == chrom) \
                                         & (data["MeanC"]< 10)].values)
                        ]
                    )
                    lsAdd.append(
                        [
                            chrom, "1", 
                            len(data.loc[(data["Chrom"] == chrom) \
                                         & (data["MeanC"]< 1)].values)
                        ]
                    )
                usedData = pd.DataFrame(
                    lsAdd, columns = ["Chrom", "Thresh", "Number"]
                )
                #Plot the data
                ax_sub = imgFigu.add_subplot(gridout[cPlt])
                sns.barplot(
                    y="Number", x="Chrom", hue="Thresh", 
                    palette = ["green","orange", "brown", "red"], 
                    data = usedData, ax=ax_sub
                )
                if max(usedData["Number"].values) < 10:
                    ax_sub.set(ylim=(0,10))
                ax_sub.set(
                    title="Tragets with mean Coverage below Threshold \n "
                    +f"{self.dicIDsBam[intID][0]}, Reduced:{self.strReduce}, "
                    +f"Subsamples: {self.subsamples}, "
                    +f"Filtered: {self.FileClass}, BED-ID:{self.bedid}"
                )     
                ax_sub.set_ylabel("Number of Targets")
                ax_sub.set_xlabel("Chromosome")
                cPlt += 1
            
            ##Save figure
            #imgFigu.tight_layout()
            pdfFile.savefig(imgFigu)

        
   

        
    ###Plot mean per base PHRED score and read length distribution
    def PlotQCmetrics(self, ori):
        with PdfPages(self.outtmp+f"QCphred_{ori}.pdf") as pdfFile:
            
            ##Create main figure
            imgFigu, gridout = self.GetPlotGrid(4, self.bamnames)
            #plt.suptitle("Mean PHRED score and read length distribution of reads flagged as mate {}. \n Subsamples: {}, Reduced: {} \n".format(ori, self.subsamples,self.strReduce), fontsize = self.headersize)
            
            ##Get the data
            plotdata = self.phreddata.loc[self.phreddata["Mate"] == ori]
            ylimMin = min(self.phreddata["PHREDmean"]) \
                      - max(self.phreddata["PHREDsd"])
            ylimMax = max(self.phreddata["PHREDmean"]) \
                      + max(self.phreddata["PHREDsd"])
            
            ##Start plotting
            cPlt = 0
            for intID in self.dicIDsBam.keys():   #One dualplot (PHRED and len) per .bam file
                
                #Get the data
                data = plotdata.loc[plotdata["ID"]==intID]
                
                #Plot the data
                ax = imgFigu.add_subplot(gridout[cPlt])
                axes = [ax, ax.twinx()]
                axes[0].plot(data["PHREDmean"].values, color="blue")
                axes[0].fill_between(
                    range(0,len(data["PHREDmean"].values)),
                    (data["PHREDmean"] - data["PHREDsd"]).values,
                    (data["PHREDmean"] + data["PHREDsd"]).values,
                    alpha=0.3
                )
                axes[0].set(
                    ylabel = "Mean PHRED with std", 
                    ylim = (ylimMin, ylimMax)
                )
                axes[0].grid(False)
                axes[1].plot(data["ReadCount"].values, color="orange")
                axes[1].set(
                    ylabel = "% of reads showing this length", 
                    ylim = (0,1)
                )
                axes[1].grid(False)
                ax.set_title(
                    "QC metrics (PHRED and length) \n "
                    +f"{self.dicIDsBam[intID][0]}, "
                    +f"Reduced: {self.strReduce}, "
                    +f"Subsamples: {self.subsamples}, "
                    +f"Filtered: {self.FileClass}, "
                    +f"BED-ID: {self.bedid} "
                )
                ax.legend(
                    ["mean PHRED", "Length distribution"], 
                    labelcolor = ["blue","orange"]
                )
                cPlt += 1
                
            ##Save the main plot
            #imgFigu.tight_layout()
            pdfFile.savefig(imgFigu)
                
        
        
        
        
    ###Plot the mean coverage per target
    def PlotCoverage(self):

        ##Create plot
        with PdfPages(self.outtmp+"CoVplot_Raw.pdf") as pdfFile:
            
            #Create main figure            
            imgFigu, gridout = self.GetPlotGrid(1, self.bamnames)
            #plt.suptitle("Mean coverage per targetbase with std \n Subsamples: {}, Reduced: {} \n".format(self.subsamples,self.strReduce), fontsize = self.headersize)

            #Start plotting
            cPlt = 0                        #Count plots in figure
            for intID in self.dicIDsBam.keys():
                #Extract from dataframe
                bamdata = self.detaildata.loc[self.detaildata["ID"] == intID]
                   
                #Plot Coverage
                ax_sub = imgFigu.add_subplot(gridout[cPlt])
                sns.boxplot(y="MeanC", x="Chrom", data=bamdata, ax=ax_sub)
                ax_sub.set(title = "MeanC per target on each chromosome \n "
                                   +f"{self.dicIDsBam[intID][0]}, "
                                   +f"Reduced:{self.strReduce}, "
                                   +f"Subsamples: {self.subsamples}, "
                                   +f"Filtered:{self.FileClass}, "
                                   +f"BED-ID:{self.bedid}", 
                           xlabel="Chromosome", 
                           ylabel="Mean coverage"
               )
                ax_sub.grid(False)    
                cPlt += 1
            
            #Save figure
            #imgFigu.tight_layout()
            pdfFile.savefig(imgFigu)
    
    
  

    
    

            
    ###Main function for variant data plotting
    #Calls the sub-functions PlotVarNumber(), PlotVarDist() and PlotSharedVariantsInSample()
    def PlotVariantData(self, vcfnames):
        
        self.vcfnames = vcfnames
        self.vcfnum = len(vcfnames)
        #print(self.dfvariants)
        ##No identification of shared data is possible with one .vcf file only
        if self.vcfnum < 2:
            booShare = False
        else:
            booShare = True
        
        ##Set minimal samplenumber to 8 to guarantee best plotsize
        if self.vcfnum < 8:
            self.vcfnum = 8
        
        ##Calculate and plot variant numbers per .vcf file
        self.PlotVarNumber()
        
        ##Plot allelefrequency distribution
        self.PlotVarDist()
        
        ##Plot shared variants if 2 or more .vcf files are provided
        if booShare:
            self.PlotSharedVariantsInSample()
    
    
    
    
    ###Plot the number of variants found in each .vcf file
    #Is called by main function PlotVariantData() (see above)
    def PlotVarNumber(self):
        
        ##Initialize PDF document
        with PdfPages(self.outtmp+"VariantNumbers.pdf") as PdfFile:
            
            ##Create main figure
            imgFigu, gridout = self.GetPlotGrid(8, self.vcfnames)
            
            ##Set figure title
            #plt.suptitle("Number of found variants \n", fontsize = self.headersize)            
            
            ##Start plotting
            cPlt = 0
            for intID in self.dicIDsVCF:
                data = len(
                    self.dfvariants.loc[self.dfvariants["ID"] == intID]
                )
                ax0 = imgFigu.add_subplot(gridout[cPlt])
                ax0.bar(height = data, x="0")
                ax0.set(
                    title = str(
                        "Number of Variants \n "
                        +f"{self.dicIDsVCF[intID][0]}, "
                        +f"Filtered:{self.FileClass}, "+
                        +f"BED-ID:{self.bedid}"
                    )
                )
                cPlt += 1
                
                
            ##Save figure
            PdfFile.savefig(imgFigu)
        
        

    
    
    ###Plot allelefrequency of variants in .vcf files
    #Is called by main function PlotVariantData() (see above)
    def PlotVarDist(self):

        with PdfPages(self.outtmp+"AFdist.pdf") as pdfFile:
            imgFigu, gridout = self.GetPlotGrid(3, self.vcfnames)
            #plt.suptitle("Allelefrequency distribution \n", fontsize = self.headersize) 

            ##Start plotting
            intBin = 100                #Set number of bins used by sns.histplot()
            cPlt = 0
            
            for intID in self.dicIDsVCF:
                data = self.dfvariants.loc[
                    self.dfvariants["ID"] == self.dicIDsVCF[intID][0]
                ]
                self.phreddata["PHREDmean"] = pd.to_numeric(
                    self.phreddata["PHREDmean"]
                )
                ax0 = imgFigu.add_subplot(gridout[cPlt])
                graph = sns.histplot(x = "Allelefrequency",
                                     data=data,
                                     bins = intBin,
                                     alpha = 0.5,
                                     ax = ax0,
                                     log_scale = (False,True))
                ax0.set_title(
                    str(
                        "Allelefrequency distribution of variants "
                        +f"\n {self.dicIDsVCF[intID][0]}, "
                        +f"Filtered:{self.FileClass}, "
                        +f"BED-ID:{self.bedid}"
                    )
                )
                ax0.set_ylim(1,1000000)
                ax0.set_xlim(0,1)
                cPlt += 1
            pdfFile.savefig(imgFigu)
                    
                
    
            
            
    ###VENN diagramms to show shared variant information
    def PlotSharedVariantsInSample(self): 
            
            ##Start plotting
            cPlt = 0
            for comb in self.vennplots.values:
                with PdfPages(
                        self.outtmp+f"SharedVariantsInSample{cPlt}.pdf"
                        ) as pdfFile:
                #print(comb)
                    lsAllVars = []
                    lsVCFname = []
                    for intID in comb:
                        #Dataframe self.variants was created initially by this class (see __init__())
                        data = self.dfvariants.loc[
                            self.dfvariants["ID"] == intID
                        ]
                        plotdata = data.loc[:,
                                            ["Chromosome", "Position", 
                                             "Reference", "Alternative"
                                             ]
                                            ]
                        lsAllVars.append(plotdata.values.tolist())
                        lsVCFname.append(self.dicIDsVCF[intID][0])

                    #venn_3 and venn_2 needs set() objects to plot the data!
                    lsAllVars = [
                        set(tuple([tuple(x) for x in y])) for y in lsAllVars
                    ]
                    labels = get_labels(lsAllVars)
                    if len(lsVCFname) == 2:
                        fig, ax = venn2(labels, names = lsVCFname)
                    elif len(lsVCFname) == 3:
                        fig, ax = venn3(labels, names = lsVCFname)
                    elif len(lsVCFname) == 4:
                        fig, ax = venn4(labels, names = lsVCFname)
                    elif len(lsVCFname) == 5:
                        fig, ax = venn5(labels, names = lsVCFname)
                    ax.set_title(
                        str(
                            "Shared variants of .vcf \n "
                            +f"Filtered:{self.FileClass}, "
                            +f"BED-ID:{self.bedid}"
                        )
                    )
                    cPlt += 1
                    pdfFile.savefig(fig)
                    
                    
        
        
        
        
    ###Merge all created plots to create the final output
    def MergeAllPlots(self, dtime):
        
        ##Define order of plots
        lsOrder = ["QCphred_1.pdf",
                   "QCphred_2.pdf",
                   "OnTarget.pdf",
                   "CoVplot_Raw.pdf",
                   "CoVplot_FileClass.pdf",
                   "LowCov.pdf",
                   "VariantNumbers.pdf",
                   "AFdist.pdf"
                   ]
        
        #Collect pathes of all pdfs
        pathes = glob(self.outtmp+"*.pdf")
        
        #Start collecting plots in order
        pdfFileloc = []
        for filenames in lsOrder:
            for i in pathes:
                if i.split("/")[-1] == filenames:
                    pdfFileloc.append(i)
        for remains in pathes:
            if remains.split("/")[-1] not in lsOrder:
                pdfFileloc.append(remains)
        #Merge plots
        Pdfmerge = PdfFileMerger()
        for pdfs in pdfFileloc:
            Pdfmerge.append(pdfs)
        
        #Save merged plot
        Pdfmerge.write(self.out+f"{dtime}_SampleComparison.pdf")
        Pdfmerge.close()
        
        ##Delete temp data
        pathdel = self.outtmp[:self.outtmp.find("tmp")+4]
        self.comptoollog.info(f"Removing tmp folder from {pathdel}")
        shutil.rmtree(pathdel)
        


                
            
        
        